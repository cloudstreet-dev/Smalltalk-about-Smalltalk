# Chapter 9: Conclusion - Why We Can't Quit Smalltalk

[← Previous: Influences and Legacy](08-influences.md) | [Appendix →](appendix.md)

---

Here we are in 2025, and Smalltalk is still the language that makes programmers feel feelings. It's the ex that got away, the road not taken, the alternative timeline where programming stayed fun. Every developer who seriously learns Smalltalk has the same experience: enlightenment followed by frustration that the rest of the world doesn't get it.

## The Eternal Appeal

Smalltalk offers something no modern language can: coherence. In a world where JavaScript developers need seventeen tools to build "Hello World," where Python can't decide if it's version 2 or 3, where every language is actually three languages (the language, the build system, and the package manager), Smalltalk remains beautifully, stubbornly whole.

It's not just a language; it's a philosophy rendered in code. The idea that programming should be conversational, that development should be live, that systems should be understandable—these aren't features, they're beliefs. And beliefs, unlike syntax, don't deprecate.

## The Communities That Won't Die

Each Smalltalk implementation has cultivated a community that's part user group, part philosophy club, part support group. They're the people who see `3 + 4 * 5` equaling 35 and think, "Yes, that makes sense." They're the developers who believe that if you can't inspect it, you don't really own it. They're the programmers who think version control should version objects, not text.

These communities are small but mighty, like specialized evolutionary niches that produce remarkable adaptations. They build things that shouldn't be possible, solve problems in ways that shouldn't work, and smile knowingly when the mainstream discovers "new" ideas that Smalltalk had forty years ago.

## The Future That's Always Coming

Every year, someone predicts this will be Smalltalk's year. It never is, and that's okay. Smalltalk doesn't need to win; it needs to exist. It's the control group in the great programming language experiment, the reminder of what we gave up for adoption, the road map to where we could have gone.

In 2025, Smalltalk is exactly where it should be: alive in its various forms, each one pushing boundaries in its own direction. Squeak keeps playing, Pharo keeps building, Glamorous Toolkit keeps molding, GNU Smalltalk keeps scripting, and Amber keeps transpiling. Together, they form a constellation of what programming could be if we optimized for thinking instead of typing.

## The Last Message

If Smalltalk has taught us anything, it's that in programming, as in life, the journey matters more than the destination. Every Smalltalk implementation is on its own journey, taking its own path through the landscape of computational possibility. They may never converge, may never dominate, may never "win" in any conventional sense.

But they persist. And in persisting, they remind us that programming is more than producing executables. It's about having conversations with computers, growing gardens of objects, and occasionally, just occasionally, catching a glimpse of what Alan Kay saw all those years ago: a medium for human thought that happens to run on machines.

## The Programming Language That Programs You

There's an old joke that you don't learn Smalltalk—Smalltalk learns you. After spending time in any Smalltalk environment, you start thinking differently about programming. You start seeing objects everywhere. You wonder why your IDE can't inspect running processes. You get frustrated when you can't send messages to numbers. You've been Smalltalked.

This mental model shift is Smalltalk's real legacy. It's not about the languages that copied its features—it's about the programmers who copied its thinking. Once you understand that everything can be an object, that computation is just message passing, that development environments should be live and moldable, you can't go back. You're ruined for conventional programming, in the best possible way.

## The Questions That Matter

Smalltalk forces us to ask uncomfortable questions about modern programming:

- Why do we accept compilation as a separate step?
- Why do we version text instead of semantic structures?
- Why do we tolerate dead code that only comes alive when run?
- Why do we use tools that don't understand our programs?
- Why do we program in languages that fight us instead of help us?

These aren't technical questions—they're philosophical ones. And Smalltalk's various implementations offer different answers, each valid in its own context, each pointing toward a different possible future.

## The Smalltalk Paradox

The paradox of Smalltalk is that its failure enabled its success. If Smalltalk had won the language wars of the 1990s, it would have been frozen in time, standardized to death, committed to backward compatibility. Instead, by remaining on the margins, it stayed free to evolve, experiment, and inspire.

Each implementation we've explored represents a different evolutionary branch, unconstrained by market pressures or compatibility requirements. They're free to be weird, to be opinionated, to be right rather than popular. And in that freedom, they continue to explore what programming could be.

## The Final Thought

So here's to Smalltalk in all its forms—may it forever remain the language we measure all others against, the standard we fail to meet, and the reminder that in programming, being right is more important than being popular.

After all, in a world where everything is an object, shouldn't programming languages be interesting?

And perhaps that's why we can't quit Smalltalk. It's not just a programming language—it's a reminder that programming was supposed to be powerful, expressive, and yes, even fun. Every time we fight with a build system, wrestle with dependencies, or debug through print statements, Smalltalk is there in the back of our minds, whispering, "It doesn't have to be this way."

We may never program in Smalltalk professionally. The world may never adopt its image-based development or message-passing purity. But as long as programmers care about elegance, as long as we yearn for better tools, as long as we believe programming should be a conversation rather than a compilation, Smalltalk will survive.

Not as a language that conquered the world, but as an idea that conquered our minds.

And really, which victory matters more?

---

*"In Smalltalk, everything happens somewhere else." - Adele Goldberg*

*And that, perhaps, is the most honest thing ever said about programming.*

---

[← Previous: Influences and Legacy](08-influences.md) | [Appendix →](appendix.md)